# Жизненный цикл запроса к серверу

<!-- TODO: Добавить диаграмму -->

## Вступление

При выполнении реальных задач, всегда будут возникать вопросы к
архитектуре, для реализации той или иной функциональности. Для
комфортной разработки на Egal Server нужно понимать как он работает.

Текущая статья позволит вам более углубленно понять, как Egal Server
работает "под капотом". После ознакомления с данной статьей все станет
менее "магическим".


## Обзор жизненного цикла

### Появление запроса

Запрос появляется на стороне клиента ( Web Service , Egal Client и др.).
Запрос является RabbitMQ сообщением состоящим из тела запроса и ключа
маршрутизации. Тело запроса предоставляется в виде `JSON` и содержит
необходимую информацию для обращения к действию. Ключ маршрутизации
предоставляется в виде строки, которая состоит из слов с разделителем в
виде точки.

Вид тела запроса:

```json
{
    "type": "action", // Тип. Для запроса всегда `action`
    "service_name": "service", // Название сервиса
    "model_name": "Model", // Название модели
    "action_name": "doSomething", // Название действия
    "parameters": [], // Параметры действия
    "token": null, // UST
    "uuid": "457db8ed-c4de-466c-99c6-5665aa012cf9", // Уникальный идентификатор сообщения
    "hash": "04db8b86c8abbdd28e7cafa03b343ef9" // Hash тела сообщения
}
```

> Про UST подробнее смотри [документацию](/server/autorization.md).

> Параметры действия соответствуют параметрам функции. Параметры
> стандартного CRUD можно посмотреть [тут](/server/crud/index.md).
> Параметры уникальных действия запрашивайте у разработчиков.

Ключ маршрутизации сообщения:

```text
service.Model.doSomething.action
   |      |        |        |
   |      |        |        Тип сообщения
   |      |        Название действия
   |      Название модели
   Название сервиса
```


### Отправка запроса

Перед отправкой нужно подготовить структуру получения ответных
сообщений:
1. Создать очередь с названием идентичным `uuid` сообщения.
2. Привязать ранее созданную очередь к `amq.direct` с ключом
   маршрутизации идентичным названию очереди и `uuid` сообщения.

Теперь сама отправка:

1. Сформированное сообщение запроса выполнения действия отсылается в
   `amq.topic` обменник RabbitMQ.
2. Сообщение из `amq.topic` попадает в `{service}.balancer.exchange`.

> `amq.topic` привязан к `service.balancer.exchange` по ключу
> маршрутизации `{service}.*.*.action`.

3. Сообщение из `{service}.balancer.exchange` попадает в одну из
   очередей `{service}.{some-uuid}.queue`.

> `{service}.balancer.exchange` балансирует все сообщения между
> привязанными к нему очередями. То есть — будучи у балансера 3
> привязанные очереди, сообщение отправится в одну из них.

4. Очередь `{service}.{some-uuid}.queue` слушает и обрабатывает один из
   демонов-слушателей сервиса.

> Все нестандартные структуры RabbitMQ формируются при начале работы
> демона сервиса.


### Обработка запроса

1. Слушатель сервиса получает сообщения запроса выполнения действия.
2. Отправляет сообщение начала обработки запроса в `amq.direct` с ключом
   маршрутизации идентичным `uuid` сообщения запроса и телом вида:

```json
{
    "type": "start_processing", // Тип. Для сообщения начала обработки всегда `start_processing`
    "started_at": "2021-02-17T03:40:09.928674Z", // Время начала обработки запроса
    "uuid": "05df2b40-e6c0-4d24-b47f-602e515d460b", // Уникальный идентификатор сообщения
    "hash": "75c1ac5b8bab38d6b1d8de82ef690232" // Hash тела сообщения
}
```

3. Проверяет наличие модели и действия.
4. Проверяет доступ по следующим критериям: статус авторизации, роли,
   доступы.
5. Вызывает действие с указанными параметрами.
6. Формирует сообщение ответа:
   * В случае успешного вызова действия, формируется сообщение
     результата выполнения действия:

   ```json
   {
       "type": "action_result",  // Тип. Для сообщения результата выполнения действия всегда `action_result`
       "data": {}, // Возвращенные данные действия
       "uuid": "af3c6b6b-ebf7-4192-bf37-49dc276510c8", // Уникальный идентификатор сообщения
       "hash": "a7e33598c81e1c5e66593ac2ba3d7db0" // Hash тела сообщения
   }
   ```

   * В случае ошибки во время вызова действия, формируется сообщение
     ошибки выполнения действия:

   ```json
   {
       "type": "action_error", // Тип. Для сообщения ошибки выполнения действия всегда `action_error`
       "code": 0, // Код ошибки
       "message": "actionGetIte не существует в модели App\\Models\\User!", // Код ошибки
       "uuid": "d4d70ef7-0076-4fa7-b116-22fea21adc30", // Уникальный идентификатор сообщения
       "hash": "a7e33598c81e1c5e66593ac2ba3d7db0" // Hash тела сообщения
   }
   ```
7. Полученное сообщение результата выполнения действия или сообщение
   ошибки выполнения действия отправляется в `amq.direct` с ключом
   маршрутизации идентичным `uuid` сообщения запроса.


### Получение ответа от сервиса

В очередь созданную при
[подготовке к отправке запроса](#Отправка-запроса) будут приходить
сообщения обработки запроса.

